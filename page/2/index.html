<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>qiqi12138</title>
    
    <meta name="description" content="">
    <meta name="author" content="">
    
    <link href="https://qiqi12138.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://qiqi12138.github.io/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://qiqi12138.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://qiqi12138.github.io/favicon.ico">
    
    <meta name="generator" content="Hugo 0.57.2" />
    
    <link rel="alternate" type="application/atom+xml" href="https://qiqi12138.github.io/index.xml" title="qiqi12138">
    
    
  </head>
  <body class="list home">
    <header class="header">
      <nav class="nav">
        
        <h1 class="logo"><a href="https://qiqi12138.github.io">qiqi12138</a></h1>
        
        
      </nav>
    </header>
    <main class="main">












<article class="post-entry">
  <header class="entry-header">
    <h2>Node.js - 介绍</h2>
  </header>
  <section class="entry-content">
   <p>Node.js 介绍 1.1Node.js 是什么  Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.  Node.js 不是一门语言 Node.js 不是库、不是框架 Node.js 是一个 JavaScript 运行时的环境 简单点来讲就是 Node.js 可以解析和执行 JavaScript 代码 以前只有浏览器可以解析 JavaScript 代码 也就是说现在 JavaScript 可以完全脱离浏览器来运行，一切都归功于: Node.js  浏览器中的 JavaScript  EcmaScript BOM DOM  Node.js中的 JavaScript  没有 BOM、DOM EcmaScript 在 Node.js 这个 JavaScript 执行环境中为 JavaScript 提供了一些服务器级别的操作 API 例如文件读写 网络服务的构建 网络通信 http 服务器 等处理。。。  构建于 Chrome 的 V8 引擎之上  代码只是具有特定格式的字符串而已 引擎可以认识他，引擎可以帮你去解析和执行 Google Chrome 的 V8 引擎是目前公认的解析执行 JavaScript 代码最快的 Node....</p>
  </section>
  <footer class="entry-footer">
    <time>October 1, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/22-node.js-%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Vue.js - vue-cli 3.x</h2>
  </header>
  <section class="entry-content">
   <p>Vue-cli 版本 3.9.3
可以使用下列任一命令安装这个新的包：
npm install -g @vue/cli # OR yarn global add @vue/cli  安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。
你还可以用这个命令来检查其版本是否正确 (3.x)：
vue --version  自定义脚手架模板 第一步: 创建项目
vue create vue-cli-new2  第二步： Manually select features
第三步：选择依赖
 空格选择，回车确定  第四步：是否使用历史路由
 y&amp;n都可以  第五步： ESLint &#43; Standard config
第六步：是否保存模板
第七步： 找到 C:\Users\Lenovo 下的 .vuerc 文件来配置模板
安装插件 使用 vue add vuetify
 vuetify是一个ui库 使用 add 命令，使安装的插件完全融入到项目中 正常安装插件还是使用 npm install  配置文件 vue....</p>
  </section>
  <footer class="entry-footer">
    <time>March 10, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/21-vue-cli3.9.3/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Vue.js - 导航守卫</h2>
  </header>
  <section class="entry-content">
   <p>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。
记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。
全局前置守卫 你可以使用 router.beforeEach 注册一个全局前置守卫：
const router = new VueRouter({ ... }) router.beforeEach((to, from, next) =&gt; { // ... })  当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。
每个守卫方法接收三个参数：
 to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(‘/’) 或者 next({ path: ‘/’ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: &#39;home&#39; 之类的选项以及任何用在 router-link 的 to prop 或 router....</p>
  </section>
  <footer class="entry-footer">
    <time>March 9, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/20-vue-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Vue.js - 动画</h2>
  </header>
  <section class="entry-content">
   <p>动画 实现动画的两组类
v-enter &amp; v-leave-to
 v-enter [这是一个时间点] 是进入之前元素的起始状态，此时还没有开始进入 v-leave-to [这是一个时间点] 是动画离开之后，离开的终止状态，此时，元素动画已经结束了  v-enter-active &amp; v-leave-active
 v-enter-active [入场动画的时间段] v-leave-active [离场动画的时间段]  单元素/组件的过渡 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡
 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点  这里是一个典型的例子：
&lt;div id=&#34;demo&#34;&gt; &lt;button v-on:click=&#34;show = !show&#34;&gt; Toggle &lt;/button&gt; &lt;transition name=&#34;fade&#34;&gt; &lt;p v-if=&#34;show&#34;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;  new Vue({ el: &#39;#demo&#39;, data: { show: true } })  .fade-enter-active, .fade-leave-active { transition: opacity ....</p>
  </section>
  <footer class="entry-footer">
    <time>March 8, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/19-vue-%E5%8A%A8%E7%94%BB/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Vue.js - Router</h2>
  </header>
  <section class="entry-content">
   <p>vue-router 路由在 web 中有两种
 第一种是 hash 前面带# 第二种是 histroy 对象，这种路由不带#  起步 引入vue-router
npm
npm install vue-roter  如果在一个模块化工程中使用他，必须要通过 Vue.use() 明确的安装路由功能
import Vue from &#39;vue&#39; import VueRouter from &#39;vue-router&#39; // 把 VueRouter 注册到Vue Vue.use(VueRouter)  如果使用全局的 script 标签，则无须如此 (手动安装)
两种超链接  &lt;a href=&#34;#/login&#34;&gt;登录&lt;/a&gt;  普通的 a 标签会刷新整个页面  &lt;router-link to=&#34;/login&#34; tag=&#34;span&#34;&gt;login&lt;/router-link&gt;  组件路由不会，是直接跳转 tag 属性 tag=“span”: 此时 a 标签变成了 span，不管给他绑定什么标签都会实现路由  &lt;router-view/&gt;  这是 vue-router 提供的元素，专门用来当做占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 所以: 我们可以把 router-view 认为是一个占位符   基本使用 第一步 组件模板对象...</p>
  </section>
  <footer class="entry-footer">
    <time>March 7, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/18-vue-router/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Vue.js - 什么是Vue</h2>
  </header>
  <section class="entry-content">
   <p>什么是Vue.js  Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架 (React除了开发网站, 还可以开发手机APP，Vue语法也是用于进行手机App开发的，需要借助于Weex) Vue.js 是前端的主流框架之一，和Angular.js、React.js、一起，并成为三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，他不仅容易上手，还便于第三方库或既有项目整合。(Vue有配套的第三方类库，可以整合起来做大型项目的开发) 前端的主要工作？ 主要负责MVC中的V这一层；主要工作就是和页面打交道；来制作前端页面效果  为什么要学习流行框架  提高开发效率的发展历程: 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js/Vue.js (能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不在关心DOM是如何渲染的了】) 在Vue中，一个核心的概念，就是让用户不在操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；  框架和库的区别  框架: 是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node中的express!  库(插件): 提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。  从 Jquery 切换到 Zepto 从 EJS 切换到 art-template  什么是MVC  M(Model数据层) 职能单一，只负责操作数据库，执行对于的 Sql 语句，进行数据的CRUD  C: Create 增加 R: Read 读取 U: update 修改 D: Delete 删除  V(view视图层) 每当用户操作了界面，就需要进行业务的处理，都会通过网络请求，去请求后端的服务器，此时，我们的这个请求，就会被后端的App.js监听到 C(Controller逻辑层) 这里分为路由分发处理模块和业务逻辑处理，在这个模块中封装了一些具体业务逻辑处理的逻辑代码，但是，也是为了职能单一，此模块只负责处理业务  什么是MVVM MVVM是前端的视图层的开发分层开发思想，主要吧每个页面分为了M、V 和 VM 其中VM是MVVM的思想核心；因为VM是 M 和 V 之间的调度者...</p>
  </section>
  <footer class="entry-footer">
    <time>March 6, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/17-vue-%E8%AE%A4%E8%AF%86vue/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>ES6 - async函数</h2>
  </header>
  <section class="entry-content">
   <p>参考：https://es6.ruanyifeng.com/?search=async&#43;&amp;x=7&amp;y=6#docs/async
 含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。
async 函数是什么？一句话，它就是 Generator 函数的语法糖。
前文有一个 Generator 函数，依次读取两个文件。
const fs = require(&#39;fs&#39;); const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) return reject(error); resolve(data); }); }); }; const gen = function* () { const f1 = yield readFile(&#39;/etc/fstab&#39;); const f2 = yield readFile(&#39;/etc/shells&#39;); console.log(f1.toString()); console.log(f2.toString()); };  上面代码的函数gen可以写成async函数，就是下面这样。
const asyncReadFile = async function () { const f1 = await readFile(&#39;/etc/fstab&#39;); const f2 = await readFile(&#39;/etc/shells&#39;); console....</p>
  </section>
  <footer class="entry-footer">
    <time>March 5, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/16-es6-async%E5%87%BD%E6%95%B0/"></a>
</article>




<footer class="page-footer">
  <nav class="pagination">
    
    <a class="prev" href="/">← Prev Page</a>
    
    
    <a class="next" href="/page/3/">Next Page →</a>
    
  </nav>
</footer>


</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://qiqi12138.github.io">qiqi12138</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://qiqi12138.github.io/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

