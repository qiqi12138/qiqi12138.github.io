<!DOCTYPE html>
<html>
    <head>
	<meta name="generator" content="Hugo 0.57.2" />
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <title>
      
      qiqi12138
      
		</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="alternate" type="application/rss&#43;xml" href="https://qiqi12138.github.io/index.xml">
    
    <link rel="stylesheet" type="text/css" href="/assets/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/icons.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    
    <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Lato:100,100i,300,300i,400,400i,700,700i|Source+Code+Pro:300,400,500,700" rel="stylesheet">
    

    
    <script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/bigfoot/dist/bigfoot.js"></script>
    <link rel="stylesheet" type="text/css" href="/assets/bigfoot/dist/bigfoot-number.css" />
    <script type="text/javascript">
        $.bigfoot();
    </script>
    
    
</head>

    <body class="">
        <header class="main-header">
	<div class="main-header-content">
		<h1 class="blog-title">
			<a href="/">
				
           qiqi12138
				
			</a>
		</h1>
		<h2 class="blog-description"></h2>
	</div>

	<div class="nav">
    
		
	</div>
</header>

        
	<main class="content" role="main">
    
    <div class="extra-pagination">
      

<nav class="pagination" role="navigation">
    
        <a class="newer-posts" href="/">&larr; Newer Posts</a>
    
    <span class="page-number">Page 2 of 5</span>
    
        <a class="older-posts" href="/page/3/">Older Posts &rarr;</a>
    
</nav>

    </div>
		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/22-node.js-%E4%BB%8B%E7%BB%8D/">Node.js - 介绍</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      Node.js 介绍 1.1Node.js 是什么  Node.js® is a JavaScript runtime built on Chrome&rsquo;s V8 JavaScript engine.  Node.js 不是一门语言 Node.js 不是库、不是框架 Node.js 是一个 JavaScript 运行时的环境 简单点来讲就是 Node.js 可以解析和执行 JavaScript 代码 以前只有浏览器可以解析 JavaScript 代码 也就是说现在 JavaScript 可以完全脱离浏览器来运行，一切都归功于: Node.js  浏览器中的 JavaScript  EcmaScript BOM DOM  Node.js中的 JavaScript  没有 BOM、DOM EcmaScript 在 Node.js 这个 JavaScript 执行环境中为 JavaScript 提供了一些服务器级别的操作 API 例如文件读写 网络服务的构建 网络通信 http 服务器 等处理。。。  构建于 Chrome 的 V8 引擎之上  代码只是具有特定格式的字符串而已 引擎可以认识他，引擎可以帮你去解析和执行 Google Chrome 的 V8 引擎是目前公认的解析执行 JavaScript 代码最快的 Node. &hellip; <a class="read-more" href="/post/22-node.js-%E4%BB%8B%E7%BB%8D/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">October 01, 2018</time>
	</footer>
</article>

		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/21-vue-cli3.9.3/">Vue.js - vue-cli 3.x</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      Vue-cli 版本 3.9.3
可以使用下列任一命令安装这个新的包：
npm install -g @vue/cli # OR yarn global add @vue/cli  安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。
你还可以用这个命令来检查其版本是否正确 (3.x)：
vue --version  自定义脚手架模板 第一步: 创建项目
vue create vue-cli-new2  第二步： Manually select features
第三步：选择依赖
 空格选择，回车确定  第四步：是否使用历史路由
 y&amp;n都可以  第五步： ESLint + Standard config
第六步：是否保存模板
第七步： 找到 C:\Users\Lenovo 下的 .vuerc 文件来配置模板
安装插件 使用 vue add vuetify
 vuetify是一个ui库 使用 add 命令，使安装的插件完全融入到项目中 正常安装插件还是使用 npm install  配置文件 vue. &hellip; <a class="read-more" href="/post/21-vue-cli3.9.3/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 10, 2018</time>
	</footer>
</article>

		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/20-vue-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/">Vue.js - 导航守卫</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。
记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。
全局前置守卫 你可以使用 router.beforeEach 注册一个全局前置守卫：
const router = new VueRouter({ ... }) router.beforeEach((to, from, next) =&gt; { // ... })  当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。
每个守卫方法接收三个参数：
 to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(&lsquo;/&rsquo;) 或者 next({ path: &lsquo;/&rsquo; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router. &hellip; <a class="read-more" href="/post/20-vue-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 09, 2018</time>
	</footer>
</article>

		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/19-vue-%E5%8A%A8%E7%94%BB/">Vue.js - 动画</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      动画 实现动画的两组类
v-enter &amp; v-leave-to
 v-enter [这是一个时间点] 是进入之前元素的起始状态，此时还没有开始进入 v-leave-to [这是一个时间点] 是动画离开之后，离开的终止状态，此时，元素动画已经结束了  v-enter-active &amp; v-leave-active
 v-enter-active [入场动画的时间段] v-leave-active [离场动画的时间段]  单元素/组件的过渡 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡
 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点  这里是一个典型的例子：
&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;  new Vue({ el: '#demo', data: { show: true } })  .fade-enter-active, .fade-leave-active { transition: opacity . &hellip; <a class="read-more" href="/post/19-vue-%E5%8A%A8%E7%94%BB/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 08, 2018</time>
	</footer>
</article>

		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/18-vue-router/">Vue.js - Router</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      vue-router 路由在 web 中有两种
 第一种是 hash 前面带# 第二种是 histroy 对象，这种路由不带#  起步 引入vue-router
npm
npm install vue-roter  如果在一个模块化工程中使用他，必须要通过 Vue.use() 明确的安装路由功能
import Vue from 'vue' import VueRouter from 'vue-router' // 把 VueRouter 注册到Vue Vue.use(VueRouter)  如果使用全局的 script 标签，则无须如此 (手动安装)
两种超链接  &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt;  普通的 a 标签会刷新整个页面  &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;login&lt;/router-link&gt;  组件路由不会，是直接跳转 tag 属性 tag=&ldquo;span&rdquo;: 此时 a 标签变成了 span，不管给他绑定什么标签都会实现路由  &lt;router-view/&gt;  这是 vue-router 提供的元素，专门用来当做占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 所以: 我们可以把 router-view 认为是一个占位符   基本使用 第一步 组件模板对象 &hellip; <a class="read-more" href="/post/18-vue-router/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 07, 2018</time>
	</footer>
</article>

		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/17-vue-%E8%AE%A4%E8%AF%86vue/">Vue.js - 什么是Vue</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      什么是Vue.js  Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架 (React除了开发网站, 还可以开发手机APP，Vue语法也是用于进行手机App开发的，需要借助于Weex) Vue.js 是前端的主流框架之一，和Angular.js、React.js、一起，并成为三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，他不仅容易上手，还便于第三方库或既有项目整合。(Vue有配套的第三方类库，可以整合起来做大型项目的开发) 前端的主要工作？ 主要负责MVC中的V这一层；主要工作就是和页面打交道；来制作前端页面效果  为什么要学习流行框架  提高开发效率的发展历程: 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js/Vue.js (能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不在关心DOM是如何渲染的了】) 在Vue中，一个核心的概念，就是让用户不在操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；  框架和库的区别  框架: 是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node中的express!  库(插件): 提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。  从 Jquery 切换到 Zepto 从 EJS 切换到 art-template  什么是MVC  M(Model数据层) 职能单一，只负责操作数据库，执行对于的 Sql 语句，进行数据的CRUD  C: Create 增加 R: Read 读取 U: update 修改 D: Delete 删除  V(view视图层) 每当用户操作了界面，就需要进行业务的处理，都会通过网络请求，去请求后端的服务器，此时，我们的这个请求，就会被后端的App.js监听到 C(Controller逻辑层) 这里分为路由分发处理模块和业务逻辑处理，在这个模块中封装了一些具体业务逻辑处理的逻辑代码，但是，也是为了职能单一，此模块只负责处理业务  什么是MVVM MVVM是前端的视图层的开发分层开发思想，主要吧每个页面分为了M、V 和 VM 其中VM是MVVM的思想核心；因为VM是 M 和 V 之间的调度者 &hellip; <a class="read-more" href="/post/17-vue-%E8%AE%A4%E8%AF%86vue/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 06, 2018</time>
	</footer>
</article>

		
      <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/16-es6-async%E5%87%BD%E6%95%B0/">ES6 - async函数</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      参考：https://es6.ruanyifeng.com/?search=async+&amp;x=7&amp;y=6#docs/async
 含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。
async 函数是什么？一句话，它就是 Generator 函数的语法糖。
前文有一个 Generator 函数，依次读取两个文件。
const fs = require('fs'); const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) return reject(error); resolve(data); }); }); }; const gen = function* () { const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); };  上面代码的函数gen可以写成async函数，就是下面这样。
const asyncReadFile = async function () { const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console. &hellip; <a class="read-more" href="/post/16-es6-async%E5%87%BD%E6%95%B0/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 05, 2018</time>
	</footer>
</article>

		
    

<nav class="pagination" role="navigation">
    
        <a class="newer-posts" href="/">&larr; Newer Posts</a>
    
    <span class="page-number">Page 2 of 5</span>
    
        <a class="older-posts" href="/page/3/">Older Posts &rarr;</a>
    
</nav>

	</main>

        <footer class="site-footer">
  <section class="rss"><a class="subscribe-button icon-feed" href="/index.xml"></a></section>
  
  
  <section class="copyright">&copy; 2019 qiqi12138</section>
  <section class="poweredby"><a href="http://thedarkroast.com/arabica">Arabica</a> theme by Sean Lunsford. Published with <a href="https://gohugo.io">Hugo</a>.</section>
</footer>



    </body>
</html>
