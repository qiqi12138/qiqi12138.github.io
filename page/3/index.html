<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>qiqi12138</title>
    
    <meta name="description" content="">
    <meta name="author" content="">
    
    <link href="https://qiqi12138.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://qiqi12138.github.io/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://qiqi12138.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://qiqi12138.github.io/favicon.ico">
    
    <meta name="generator" content="Hugo 0.57.2" />
    
    <link rel="alternate" type="application/atom+xml" href="https://qiqi12138.github.io/index.xml" title="qiqi12138">
    
    
  </head>
  <body class="list home">
    <header class="header">
      <nav class="nav">
        
        <h1 class="logo"><a href="https://qiqi12138.github.io">qiqi12138</a></h1>
        
        
      </nav>
    </header>
    <main class="main">












<article class="post-entry">
  <header class="entry-header">
    <h2>ES6 - 箭头函数</h2>
  </header>
  <section class="entry-content">
   <p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。
语法 基础语法 (参数1, 参数2, …, 参数N) =&gt; { 函数声明 } //相当于：(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; } (参数1, 参数2, …, 参数N) =&gt; 表达式（单一） // 当只有一个参数时，圆括号是可选的： (单一参数) =&gt; {函数声明} 单一参数 =&gt; {函数声明} // 没有参数的函数应该写成一对圆括号。 () =&gt; {函数声明}  高级语法 //加括号的函数体返回对象字面表达式： 参数=&gt; ({foo: bar}) //支持剩余参数和默认参数 (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //同样支持参数列表解构 let f = ([a, b] = [1, 2], {x: c} = {x: a &#43; b}) =&gt; a &#43; b &#43; c; f(); // 6  描述 参考 “ES6 In Depth: Arrow functions” on hacks....</p>
  </section>
  <footer class="entry-footer">
    <time>March 4, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/15-es6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>ES6 - Fetch</h2>
  </header>
  <section class="entry-content">
   <p>Fetch Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。
这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。
请注意，fetch规范与jQuery.ajax()主
要有两种方式的不同，牢记：
 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。自从2017年8月25日后，默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值  进行 fetch 请求 一个基本的 fetch请求设置起来很简单。看看下面的代码：
fetch(&#39;http://example.com/movies.json&#39;) .then(function(response) { return response.json(); }) .then(function(myJson) { console.log(myJson); });  这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想fetch()到的资源路径，然后返回一个包含响应结果的promise(一个 Response 对象)。
当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 json()方法（在Bodymixin 中定义，被 Request 和 Response 对象实现）。...</p>
  </section>
  <footer class="entry-footer">
    <time>March 3, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/14-es6-fetch/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>ES6 - Promise</h2>
  </header>
  <section class="entry-content">
   <p>Promise 语法 new Promsie( function(resolve, reject) { ... } /* executor */ )  参数 executor 执行者
executor是带有 resolve 和 reject 两个参数的函数。Promise构造函数执行时立即调用 executor 函数，resolve 和 reject 两个函数作为参数传递给 executor (executor函数在Promise构造函数返回所建promise实例对象前被调用。) resolve 和 reject 函数被调用时，
分别将promise的状态改为 fulfilled (完成) 或rejected (失败)。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕 (可能成功/失败)，要么调用resolve函数来将promise状态改为fulfilled，要么调用 reject 函数将promise状态改为rejected。如果在executor函数中抛出一个错误，那么该promise状态改为rejected。executor函数的返回值被忽略。
描述 Promise 对象是一个代理对象 (代理一个值)，被代理的值在Promise对象创建时可能是为未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法 (handlers)。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象
一个 Promise 有以下几种状态
 pending：初始状态，既不是成功，也不是失败状态 fulfilled：意味着操作成功完成。 rejected：意味着操作失败  pending 状态的 Promise 对象可能会变成为 fuifilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态 (rejected) 并传递失败信息。当其中任一种情况出现时，Promise 对象的then 方法绑定的处理方法 (handlers) 就会被调用 (then方法包含两个参数: onfulfilled 和 onrejected，他们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 和 onfulfilled 方法，当 Promise 状态为rejected时，调用 then 的 onrejected 方法，所以在异步操作的完成和绑定处理方法之间不存在竞争)。...</p>
  </section>
  <footer class="entry-footer">
    <time>March 2, 2018</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/13-es6-promise/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>JS - 方法总结</h2>
  </header>
  <section class="entry-content">
   <p>浏览器 内核 ie trident Chrome webkit/blink firefox Gecko Opera presto Safari webkit
事件 鼠标事件    属性 描述 DOM     onclick 当用户点击某个对象时调用的事件句柄。 2   oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发    ondblclick 当用户双击某个对象时调用的事件句柄。 2   onmousedown 鼠标按钮被按下。 2   onmouseenter 当鼠标指针移动到元素上时触发。 2   onmouseleave 当鼠标指针移出元素时触发 2   onmousemove 鼠标被移动。 2   onmouseover 鼠标移到某元素之上。 2   onmouseout 鼠标从某元素移开。 2   onmouseup 鼠标按键被松开。     键盘事件    属性 描述 DOM     onkeydown 某个键盘按键被按下。 2   onkeypress 某个键盘按键被按下并松开。 2   onkeyup 某个键盘按键被松开。 2    框架/对象（Frame/Object）事件    属性 描述 DOM     onabort 图像的加载被中断。 ( ) 2   onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2   onerror 在加载文档或图像时发生错误。 ( , 和 )    onhashchange 该事件在当前 URL 的锚部分发生修改时触发。    onload 一张页面或一幅图像完成加载。 2   onpageshow 该事件在用户访问页面时触发    onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发    onresize 窗口或框架被重新调整大小。 2   onscroll 当文档被滚动时发生的事件。 2   onunload 用户退出页面。 (  和 ) 2    表单事件    属性 描述 DOM     onblur 元素失去焦点时触发 2   onchange 该事件在表单元素的内容改变时触发( input, keygen, select, 和 textarea) 2   onfocus 元素获取焦点时触发 2   onfocusin 元素即将获取焦点时触发 2   onfocusout 元素即将失去焦点时触发 2   oninput 元素获取用户输入时触发 3   onreset 表单重置时触发 2   onsearch 用户向搜索域输入文本时触发 ( input=“search”)    onselect 用户选取文本时触发 ( input 和 textarea) 2   onsubmit 表单提交时触发 2    剪贴板事件    属性 描述 DOM     oncopy 该事件在用户拷贝元素内容时触发    oncut 该事件在用户剪切元素内容时触发    onpaste 该事件在用户粘贴元素内容时触发     打印事件    属性 描述 DOM     onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发    onbeforeprint 该事件在页面即将开始打印时触发     拖动事件    事件 描述 DOM     ondrag 该事件在元素正在拖动时触发    ondragend 该事件在用户完成元素的拖动时触发    ondragenter 该事件在拖动的元素进入放置目标时触发    ondragleave 该事件在拖动元素离开放置目标时触发    ondragover 该事件在拖动元素在放置目标上时触发    ondragstart 该事件在用户开始拖动元素时触发    ondrop 该事件在拖动元素放置在目标区域时触发     获取属性节点    属性 / 方法 描述     document....</p>
  </section>
  <footer class="entry-footer">
    <time>October 2, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/12-js-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>JS-DOM对象</h2>
  </header>
  <section class="entry-content">
   <p>DOM 1.DOM 介绍  DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。 DOM 是万维网上使用最为广泛的API之一，因为它允许运行在浏览器中的代码访问文件中的节点并与之交互。节点可以被创建，移动或修改。事件监听器可以被添加到节点上并在给定事件发生时触发。 DOM 并不是天生就被规范好了的，它是浏览器开始实现JavaScript时才出现的。这个传统的 DOM 有时会被称为 DOM 0。现在， WHATWG维护DOM现存标准。  2. DOM 接口  Attr
 CDATASection
 CharacterData
 ChildNode
 Comment
 CustomEvent
 Document
 DocumentFragment
 DocumentType
 DOMError
 DOMException
 DOMImplementation
 DOMString
 DOMTimeStamp
 DOMStringList
 DOMTokenList
 Element
 Event
 EventTarget
 HTMLCollection
 MutationObserver
 MutationRecord
 NamedNodeMap...</p>
  </section>
  <footer class="entry-footer">
    <time>October 1, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/11-js-dom%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>JS - BOM对象</h2>
  </header>
  <section class="entry-content">
   <p>BOM 1. JavaScript Window - 浏览器对象模型  浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器”对话”。
 2. 浏览器对象模型 (BOM)  浏览器对象模型（Browser Object Model (BOM)）尚无正式标准。 由于现代浏览器已经（几乎）实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。  3. Window 对象 所有浏览器都支持 window 对象。它表示浏览器窗口。
所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。
全局变量是 window 对象的属性。
全局函数是 window 对象的方法。
甚至 HTML DOM 的 document 也是 window 对象的属性之一：
window.document.getElementById(&#34;header&#34;);  与此相同：
document.getElementById(&#34;header&#34;);  4. Window 尺寸 有三种方法能够确定浏览器窗口的尺寸。
对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：
 window.innerHeight - 浏览器窗口的内部高度(包括滚动条) window....</p>
  </section>
  <footer class="entry-footer">
    <time>September 30, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/10-js-bom%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>JS - 作用域</h2>
  </header>
  <section class="entry-content">
   <p>作用域  作用域是可访问变量的集合
 JavaScript 作用域  在 JavaScript 中, 对象和函数同样也是变量。 在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。 JavaScript 函数作用域: 作用域在函数内修改。  JavaScript 局部作用域  变量在函数内声明，变量为局部作用域。 局部变量：只能在函数内部访问。
// 此处不能调用 carName 变量 function myFunction() { var carName = &#34;Volvo&#34;; // 函数内可调用 carName 变量 }   因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。
局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。
JavaScript 全局变量  变量在函数外定义，即为全局变量。 全局变量有 全局作用域: 网页中所有脚本和函数均可使用。
var carName = &#34; Volvo&#34;; // 此处可调用 carName 变量 function myFunction() { // 函数内可调用 carName 变量 }   如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。...</p>
  </section>
  <footer class="entry-footer">
    <time>September 29, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/09-js-%E4%BD%9C%E7%94%A8%E5%9F%9F/"></a>
</article>




<footer class="page-footer">
  <nav class="pagination">
    
    <a class="prev" href="/page/2/">← Prev Page</a>
    
    
    <a class="next" href="/page/4/">Next Page →</a>
    
  </nav>
</footer>


</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://qiqi12138.github.io">qiqi12138</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://qiqi12138.github.io/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

