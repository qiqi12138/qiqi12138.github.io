<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>JS - 闭包 - qiqi12138</title>
    
    <meta name="description" content="闭包 1. 如何产生闭包？  当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露 内存泄露: 内存占用的越多，剩余内存会越来越少 (像泄露出去一样，可以用的东西越来越少)  2. 闭包到底是什么？  使用 chrome 调试查看 理解一: 闭包是嵌套函数的内部函数 (绝大多数人) 理解二: 包含被引用变量 (函数) 的对象 (极少数人) 注意: 闭包存在于嵌套的内部函数中  3. 产生闭包的条件  函数嵌套 内部函数引用了外部函数的数据 (变量/函数)
function fn1 () { var a = 2 var b = &#39;abc&#39; function fn2 () { //执行函数定义就会产生闭包(不用调用内部函数) console.log(a) } //fn2() } fn1()   4. 闭包的作用  使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的声明周期)
 让函数外部可以操作 (读写) 到函数内部的数据(变量/函数)
  问题
 函数执行完后，函数内部声明的局部变量是否还存在？ 一般是不存在，存在于闭包才可能存在 在函数外部能直接访问函数内部的局部变量吗？ 但是可以通过闭包让外部操作他  5.">
    <meta name="author" content="">
    
    <link href="https://qiqi12138.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://qiqi12138.github.io/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://qiqi12138.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://qiqi12138.github.io/favicon.ico">
    
    <meta name="generator" content="Hugo 0.57.2" />
    
    <link rel="alternate" type="application/atom+xml" href="https://qiqi12138.github.io/index.xml" title="qiqi12138">
    
    
  </head>
  <body class="single">
    <header class="header">
      <nav class="nav">
        
        <p class="logo"><a href="https://qiqi12138.github.io">qiqi12138</a></p>
        
        
      </nav>
    </header>
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">JS - 闭包</h1>
    <div class="post-meta">September 26, 2017</div>
  </header>
  <div class="post-content">

<h1 id="闭包">闭包</h1>

<h4 id="1-如何产生闭包">1. 如何产生闭包？</h4>

<ul>
<li>当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露</li>
<li>内存泄露: 内存占用的越多，剩余内存会越来越少 (像泄露出去一样，可以用的东西越来越少)</li>
</ul>

<h4 id="2-闭包到底是什么">2. 闭包到底是什么？</h4>

<ul>
<li>使用 chrome 调试查看</li>
<li><strong>理解一:</strong> 闭包是嵌套函数的内部函数 (绝大多数人)</li>
<li><strong>理解二:</strong> 包含被引用变量 (函数) 的对象 (极少数人)</li>
<li>注意: 闭包存在于嵌套的内部函数中</li>
</ul>

<h4 id="3-产生闭包的条件">3. 产生闭包的条件</h4>

<ul>
<li>函数嵌套</li>

<li><p>内部函数引用了外部函数的数据 (变量/函数)</p>

<pre><code class="language-js">function fn1 () {
var a = 2
var b = 'abc'
function fn2 () { //执行函数定义就会产生闭包(不用调用内部函数)
   	console.log(a)
}
//fn2()
}
fn1()
</code></pre></li>
</ul>

<h3 id="4-闭包的作用">4. 闭包的作用</h3>

<ul>
<li><p>使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的声明周期)</p></li>

<li><p>让函数外部可以操作 (读写) 到函数内部的数据(变量/函数)</p></li>
</ul>

<p>问题</p>

<ul>
<li>函数执行完后，函数内部声明的局部变量是否还存在？ <strong>一般是不存在，存在于闭包才可能存在</strong></li>
<li>在函数外部能直接访问函数内部的局部变量吗？ <strong>但是可以通过闭包让外部操作他</strong></li>
</ul>

<h3 id="5-闭包的生命周期">5. 闭包的生命周期</h3>

<ul>
<li><p>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</p></li>

<li><p>死亡: 在嵌套的内部函数成为垃圾对象时</p>

<pre><code class="language-js">function fn1 () {
  // 此时闭包已经产生了(因为函数提升，内部函数对象已经创建了)
  var a = 2
  function fn2 () {
      a ++
      console.log(a)
  }
  return fn2
}
var f = fn1()
f() //3
f() //4
f = null //闭包死亡(包含闭包的函数对象称为了垃圾对象)
</code></pre></li>
</ul>
</div>
  
  
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://qiqi12138.github.io">qiqi12138</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://qiqi12138.github.io/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

