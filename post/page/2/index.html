<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <title>
      
      Posts - qiqi12138
      
		</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="alternate" type="application/rss&#43;xml" href="https://qiqi12138.github.io/post/index.xml">
    
    <link rel="stylesheet" type="text/css" href="/assets/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/icons.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    
    <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Lato:100,100i,300,300i,400,400i,700,700i|Source+Code+Pro:300,400,500,700" rel="stylesheet">
    

    
    <script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/bigfoot/dist/bigfoot.js"></script>
    <link rel="stylesheet" type="text/css" href="/assets/bigfoot/dist/bigfoot-number.css" />
    <script type="text/javascript">
        $.bigfoot();
    </script>
    
    
</head>

    <body class="tag-template">
        <header class="main-header">
	<div class="main-header-content">
		<h1 class="blog-title">
			<a href="/">
				
           qiqi12138
				
			</a>
		</h1>
		<h2 class="blog-description"></h2>
	</div>

	<div class="nav">
    
		
	</div>
</header>

        

<main class="content" role="main">
  

	<div class="extra-pagination">
	    

<nav class="pagination" role="navigation">
    
        <a class="newer-posts" href="/post/">&larr; Newer Posts</a>
    
    <span class="page-number">Page 2 of 3</span>
    
        <a class="older-posts" href="/post/page/3/">Older Posts &rarr;</a>
    
</nav>

	</div>
  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/19-vue-%E5%8A%A8%E7%94%BB/">Vue.js - 动画</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      动画 实现动画的两组类
v-enter &amp; v-leave-to
 v-enter [这是一个时间点] 是进入之前元素的起始状态，此时还没有开始进入 v-leave-to [这是一个时间点] 是动画离开之后，离开的终止状态，此时，元素动画已经结束了  v-enter-active &amp; v-leave-active
 v-enter-active [入场动画的时间段] v-leave-active [离场动画的时间段]  单元素/组件的过渡 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡
 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点  这里是一个典型的例子：
&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;  new Vue({ el: '#demo', data: { show: true } })  .fade-enter-active, .fade-leave-active { transition: opacity . &hellip; <a class="read-more" href="/post/19-vue-%E5%8A%A8%E7%94%BB/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 08, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/18-vue-router/">Vue.js - Router</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      vue-router 路由在 web 中有两种
 第一种是 hash 前面带# 第二种是 histroy 对象，这种路由不带#  起步 引入vue-router
npm
npm install vue-roter  如果在一个模块化工程中使用他，必须要通过 Vue.use() 明确的安装路由功能
import Vue from 'vue' import VueRouter from 'vue-router' // 把 VueRouter 注册到Vue Vue.use(VueRouter)  如果使用全局的 script 标签，则无须如此 (手动安装)
两种超链接  &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt;  普通的 a 标签会刷新整个页面  &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;login&lt;/router-link&gt;  组件路由不会，是直接跳转 tag 属性 tag=&ldquo;span&rdquo;: 此时 a 标签变成了 span，不管给他绑定什么标签都会实现路由  &lt;router-view/&gt;  这是 vue-router 提供的元素，专门用来当做占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 所以: 我们可以把 router-view 认为是一个占位符   基本使用 第一步 组件模板对象 &hellip; <a class="read-more" href="/post/18-vue-router/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 07, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/17-vue-%E8%AE%A4%E8%AF%86vue/">Vue.js - 什么是Vue</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      什么是Vue.js  Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架 (React除了开发网站, 还可以开发手机APP，Vue语法也是用于进行手机App开发的，需要借助于Weex) Vue.js 是前端的主流框架之一，和Angular.js、React.js、一起，并成为三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，他不仅容易上手，还便于第三方库或既有项目整合。(Vue有配套的第三方类库，可以整合起来做大型项目的开发) 前端的主要工作？ 主要负责MVC中的V这一层；主要工作就是和页面打交道；来制作前端页面效果  为什么要学习流行框架  提高开发效率的发展历程: 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js/Vue.js (能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不在关心DOM是如何渲染的了】) 在Vue中，一个核心的概念，就是让用户不在操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；  框架和库的区别  框架: 是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node中的express!  库(插件): 提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。  从 Jquery 切换到 Zepto 从 EJS 切换到 art-template  什么是MVC  M(Model数据层) 职能单一，只负责操作数据库，执行对于的 Sql 语句，进行数据的CRUD  C: Create 增加 R: Read 读取 U: update 修改 D: Delete 删除  V(view视图层) 每当用户操作了界面，就需要进行业务的处理，都会通过网络请求，去请求后端的服务器，此时，我们的这个请求，就会被后端的App.js监听到 C(Controller逻辑层) 这里分为路由分发处理模块和业务逻辑处理，在这个模块中封装了一些具体业务逻辑处理的逻辑代码，但是，也是为了职能单一，此模块只负责处理业务  什么是MVVM MVVM是前端的视图层的开发分层开发思想，主要吧每个页面分为了M、V 和 VM 其中VM是MVVM的思想核心；因为VM是 M 和 V 之间的调度者 &hellip; <a class="read-more" href="/post/17-vue-%E8%AE%A4%E8%AF%86vue/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 06, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/16-es6-async%E5%87%BD%E6%95%B0/">ES6 - async函数</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      参考：https://es6.ruanyifeng.com/?search=async+&amp;x=7&amp;y=6#docs/async
 含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。
async 函数是什么？一句话，它就是 Generator 函数的语法糖。
前文有一个 Generator 函数，依次读取两个文件。
const fs = require('fs'); const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) return reject(error); resolve(data); }); }); }; const gen = function* () { const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); };  上面代码的函数gen可以写成async函数，就是下面这样。
const asyncReadFile = async function () { const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console. &hellip; <a class="read-more" href="/post/16-es6-async%E5%87%BD%E6%95%B0/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 05, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/15-es6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/">ES6 - 箭头函数</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。
语法 基础语法 (参数1, 参数2, …, 参数N) =&gt; { 函数声明 } //相当于：(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; } (参数1, 参数2, …, 参数N) =&gt; 表达式（单一） // 当只有一个参数时，圆括号是可选的： (单一参数) =&gt; {函数声明} 单一参数 =&gt; {函数声明} // 没有参数的函数应该写成一对圆括号。 () =&gt; {函数声明}  高级语法 //加括号的函数体返回对象字面表达式： 参数=&gt; ({foo: bar}) //支持剩余参数和默认参数 (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //同样支持参数列表解构 let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6  描述 参考 &ldquo;ES6 In Depth: Arrow functions&rdquo; on hacks. &hellip; <a class="read-more" href="/post/15-es6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 04, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/14-es6-fetch/">ES6 - Fetch</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      Fetch Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。
这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。
请注意，fetch规范与jQuery.ajax()主
要有两种方式的不同，牢记：
 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。自从2017年8月25日后，默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值  进行 fetch 请求 一个基本的 fetch请求设置起来很简单。看看下面的代码：
fetch('http://example.com/movies.json') .then(function(response) { return response.json(); }) .then(function(myJson) { console.log(myJson); });  这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想fetch()到的资源路径，然后返回一个包含响应结果的promise(一个 Response 对象)。
当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 json()方法（在Bodymixin 中定义，被 Request 和 Response 对象实现）。 &hellip; <a class="read-more" href="/post/14-es6-fetch/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 03, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/13-es6-promise/">ES6 - Promise</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      Promise 语法 new Promsie( function(resolve, reject) { ... } /* executor */ )  参数 executor 执行者
executor是带有 resolve 和 reject 两个参数的函数。Promise构造函数执行时立即调用 executor 函数，resolve 和 reject 两个函数作为参数传递给 executor (executor函数在Promise构造函数返回所建promise实例对象前被调用。) resolve 和 reject 函数被调用时，
分别将promise的状态改为 fulfilled (完成) 或rejected (失败)。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕 (可能成功/失败)，要么调用resolve函数来将promise状态改为fulfilled，要么调用 reject 函数将promise状态改为rejected。如果在executor函数中抛出一个错误，那么该promise状态改为rejected。executor函数的返回值被忽略。
描述 Promise 对象是一个代理对象 (代理一个值)，被代理的值在Promise对象创建时可能是为未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法 (handlers)。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象
一个 Promise 有以下几种状态
 pending：初始状态，既不是成功，也不是失败状态 fulfilled：意味着操作成功完成。 rejected：意味着操作失败  pending 状态的 Promise 对象可能会变成为 fuifilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态 (rejected) 并传递失败信息。当其中任一种情况出现时，Promise 对象的then 方法绑定的处理方法 (handlers) 就会被调用 (then方法包含两个参数: onfulfilled 和 onrejected，他们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 和 onfulfilled 方法，当 Promise 状态为rejected时，调用 then 的 onrejected 方法，所以在异步操作的完成和绑定处理方法之间不存在竞争)。 &hellip; <a class="read-more" href="/post/13-es6-promise/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">March 02, 2018</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/12-js-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">JS - 方法总结</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      浏览器 内核 ie trident Chrome webkit/blink firefox Gecko Opera presto Safari webkit
事件 鼠标事件    属性 描述 DOM     onclick 当用户点击某个对象时调用的事件句柄。 2   oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发    ondblclick 当用户双击某个对象时调用的事件句柄。 2   onmousedown 鼠标按钮被按下。 2   onmouseenter 当鼠标指针移动到元素上时触发。 2   onmouseleave 当鼠标指针移出元素时触发 2   onmousemove 鼠标被移动。 2   onmouseover 鼠标移到某元素之上。 2   onmouseout 鼠标从某元素移开。 2   onmouseup 鼠标按键被松开。     键盘事件    属性 描述 DOM     onkeydown 某个键盘按键被按下。 2   onkeypress 某个键盘按键被按下并松开。 2   onkeyup 某个键盘按键被松开。 2    框架/对象（Frame/Object）事件    属性 描述 DOM     onabort 图像的加载被中断。 ( ) 2   onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2   onerror 在加载文档或图像时发生错误。 ( , 和 )    onhashchange 该事件在当前 URL 的锚部分发生修改时触发。    onload 一张页面或一幅图像完成加载。 2   onpageshow 该事件在用户访问页面时触发    onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发    onresize 窗口或框架被重新调整大小。 2   onscroll 当文档被滚动时发生的事件。 2   onunload 用户退出页面。 (  和 ) 2    表单事件    属性 描述 DOM     onblur 元素失去焦点时触发 2   onchange 该事件在表单元素的内容改变时触发( input, keygen, select, 和 textarea) 2   onfocus 元素获取焦点时触发 2   onfocusin 元素即将获取焦点时触发 2   onfocusout 元素即将失去焦点时触发 2   oninput 元素获取用户输入时触发 3   onreset 表单重置时触发 2   onsearch 用户向搜索域输入文本时触发 ( input=&ldquo;search&rdquo;)    onselect 用户选取文本时触发 ( input 和 textarea) 2   onsubmit 表单提交时触发 2    剪贴板事件    属性 描述 DOM     oncopy 该事件在用户拷贝元素内容时触发    oncut 该事件在用户剪切元素内容时触发    onpaste 该事件在用户粘贴元素内容时触发     打印事件    属性 描述 DOM     onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发    onbeforeprint 该事件在页面即将开始打印时触发     拖动事件    事件 描述 DOM     ondrag 该事件在元素正在拖动时触发    ondragend 该事件在用户完成元素的拖动时触发    ondragenter 该事件在拖动的元素进入放置目标时触发    ondragleave 该事件在拖动元素离开放置目标时触发    ondragover 该事件在拖动元素在放置目标上时触发    ondragstart 该事件在用户开始拖动元素时触发    ondrop 该事件在拖动元素放置在目标区域时触发     获取属性节点    属性 / 方法 描述     document. &hellip; <a class="read-more" href="/post/12-js-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">October 02, 2017</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/11-js-dom%E5%AF%B9%E8%B1%A1/">JS-DOM对象</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      DOM 1.DOM 介绍  DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。 DOM 是万维网上使用最为广泛的API之一，因为它允许运行在浏览器中的代码访问文件中的节点并与之交互。节点可以被创建，移动或修改。事件监听器可以被添加到节点上并在给定事件发生时触发。 DOM 并不是天生就被规范好了的，它是浏览器开始实现JavaScript时才出现的。这个传统的 DOM 有时会被称为 DOM 0。现在， WHATWG维护DOM现存标准。  2. DOM 接口  Attr
 CDATASection
 CharacterData
 ChildNode
 Comment
 CustomEvent
 Document
 DocumentFragment
 DocumentType
 DOMError
 DOMException
 DOMImplementation
 DOMString
 DOMTimeStamp
 DOMStringList
 DOMTokenList
 Element
 Event
 EventTarget
 HTMLCollection
 MutationObserver
 MutationRecord
 NamedNodeMap &hellip; <a class="read-more" href="/post/11-js-dom%E5%AF%B9%E8%B1%A1/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">October 01, 2017</time>
	</footer>
</article>

  
  <article class="post">
	<header class="post-header">
    
		<h2 class="post-title"><a href="/post/10-js-bom%E5%AF%B9%E8%B1%A1/">JS - BOM对象</a></h2>
	</header>
	<section class="post-excerpt">
    <p>
      BOM 1. JavaScript Window - 浏览器对象模型  浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器&rdquo;对话&rdquo;。
 2. 浏览器对象模型 (BOM)  浏览器对象模型（Browser Object Model (BOM)）尚无正式标准。 由于现代浏览器已经（几乎）实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。  3. Window 对象 所有浏览器都支持 window 对象。它表示浏览器窗口。
所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。
全局变量是 window 对象的属性。
全局函数是 window 对象的方法。
甚至 HTML DOM 的 document 也是 window 对象的属性之一：
window.document.getElementById(&quot;header&quot;);  与此相同：
document.getElementById(&quot;header&quot;);  4. Window 尺寸 有三种方法能够确定浏览器窗口的尺寸。
对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：
 window.innerHeight - 浏览器窗口的内部高度(包括滚动条) window. &hellip; <a class="read-more" href="/post/10-js-bom%E5%AF%B9%E8%B1%A1/">&raquo;</a>
    </p>
	</section>
	<footer class="post-meta">
    <time class="post-date">September 30, 2017</time>
	</footer>
</article>

  
  

<nav class="pagination" role="navigation">
    
        <a class="newer-posts" href="/post/">&larr; Newer Posts</a>
    
    <span class="page-number">Page 2 of 3</span>
    
        <a class="older-posts" href="/post/page/3/">Older Posts &rarr;</a>
    
</nav>

</main>

        <footer class="site-footer">
  <section class="rss"><a class="subscribe-button icon-feed" href="/index.xml"></a></section>
  
  
  <section class="copyright">&copy; 2019 qiqi12138</section>
  <section class="poweredby"><a href="http://thedarkroast.com/arabica">Arabica</a> theme by Sean Lunsford. Published with <a href="https://gohugo.io">Hugo</a>.</section>
</footer>



    </body>
</html>
