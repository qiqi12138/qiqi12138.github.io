<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Posts - qiqi12138</title>
    
    <meta name="description" content="">
    <meta name="author" content="">
    
    <link href="https://qiqi12138.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://qiqi12138.github.io/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://qiqi12138.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://qiqi12138.github.io/favicon.ico">
    
    <meta name="generator" content="Hugo 0.57.2" />
    
    <link rel="alternate" type="application/atom+xml" href="https://qiqi12138.github.io/index.xml" title="qiqi12138">
    
    
  </head>
  <body class="list">
    <header class="header">
      <nav class="nav">
        
        <p class="logo"><a href="https://qiqi12138.github.io">qiqi12138</a></p>
        
        
      </nav>
    </header>
    <main class="main">





<header class="page-header">
  <h1>Posts</h1>
</header>






<article class="post-entry">
  <header class="entry-header">
    <h2>JS - 数据类型</h2>
  </header>
  <section class="entry-content">
   <p>数据类型 基本数据类型 基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol (ECMAScript2016新增)。
多数情况下，基本类型直接代表了最底层的语言实现。
所有基本类型的值都是不可改变的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。
JavaScript 中的基本类型包装对象 除了 null 和 undefined之外，所有基本类型都有其对应的包装对象：
 String 为字符串基本类型。 Number 为数值基本类型。 Boolean 为布尔基本类型。 Symbol 为字面量基本类型。  这个包裹对象的valueOf()方法返回基本类型值。...</p>
  </section>
  <footer class="entry-footer">
    <time>September 28, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/08-js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>JS - 面向对象</h2>
  </header>
  <section class="entry-content">
   <p>JavaScript 的核心是支持面向对象的，同时它也提供了强大灵活的 OOP 语言能力。本文从对面向对象编程的介绍开始，带您探索 JavaScript 的对象模型，最后描述 JavaScript 当中面向对象编程的一些概念。
面向对象编程 面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式。它使用先前建立的范例，包括模块化，多态和封装几种技术。今天，许多流行的编程语言（如Java，JavaScript，C＃，C&#43; &#43;，Python，PHP，Ruby和Objective-C）都支持面向对象编程（OOP）。
相对于「一个程序只是一些函数的集合，或简单的计算机指令列表。」的传统软件设计观念而言，面向对象编程可以看作是使用一系列对象相互协作的软件设计。 在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。
面向对象程序设计的目的是在编程中促进更好的灵活性和可维护性，在大型软件工程中广为流行。凭借其对模块化的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 1, 它能更直接地分析, 编码和理解复杂的情况和过程。
术语  Namespace 命名空间  允许开发人员在一个独特，应用相关的名字的名称下捆绑所有功能的容器。
 Class 类  定义对象的特征。它是对象的属性和方法的模板定义。
 Object 对象  类的一个实例。
 Property 属性  对象的特征，比如颜色。
 Method 方法  对象的能力，比如行走。
 Constructor 构造函数  对象初始化的瞬间，被调用的方法。通常它的名字与包含它的类一致。
 Inheritance 继承  一个类可以继承另一个类的特征。
 Encapsulation 封装  一种把数据和相关的方法绑定在一起使用的方法。
 Abstraction 抽象  结合复杂的继承，方法，属性的对象能够模拟现实的模型。
 Polymorphism 多态  多意为「许多」，态意为「形态」。不同类可以定义相同的方法或属性。...</p>
  </section>
  <footer class="entry-footer">
    <time>September 27, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/07-js-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>JS - 闭包</h2>
  </header>
  <section class="entry-content">
   <p>闭包 1. 如何产生闭包？  当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露 内存泄露: 内存占用的越多，剩余内存会越来越少 (像泄露出去一样，可以用的东西越来越少)  2. 闭包到底是什么？  使用 chrome 调试查看 理解一: 闭包是嵌套函数的内部函数 (绝大多数人) 理解二: 包含被引用变量 (函数) 的对象 (极少数人) 注意: 闭包存在于嵌套的内部函数中  3. 产生闭包的条件  函数嵌套 内部函数引用了外部函数的数据 (变量/函数)
function fn1 () { var a = 2 var b = &#39;abc&#39; function fn2 () { //执行函数定义就会产生闭包(不用调用内部函数) console.log(a) } //fn2() } fn1()   4. 闭包的作用  使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的声明周期)
 让函数外部可以操作 (读写) 到函数内部的数据(变量/函数)
  问题
 函数执行完后，函数内部声明的局部变量是否还存在？ 一般是不存在，存在于闭包才可能存在 在函数外部能直接访问函数内部的局部变量吗？ 但是可以通过闭包让外部操作他  5....</p>
  </section>
  <footer class="entry-footer">
    <time>September 26, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/06-js-%E9%97%AD%E5%8C%85/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>十大算法</h2>
  </header>
  <section class="entry-content">
   <p>算法一：快速排序算法 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
算法步骤：
1 从数列中挑出一个元素，称为 “基准”（pivot），
2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
算法二：堆排序算法 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
堆排序的平均时间复杂度为Ο(nlogn) 。
算法步骤：
创建一个堆H[0..n-1]
把堆首（最大值）和堆尾互换
\3. 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
\4. 重复步骤2，直到堆的尺寸为1
算法三：归并排序 归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
算法步骤：
\1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
\2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
\3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
\4. 重复步骤3直到某一指针达到序列尾
\5. 将另一序列剩下的所有元素直接复制到合并序列尾
算法四：二分查找算法 二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。
算法五：BFPRT(线性查找算法) BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。
算法步骤：
\1. 将n个元素每5个一组，分成n/5(上界)组。
\2. 取出每一组的中位数，任意排序方法，比如插入排序。
\3. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。
\4. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。
\5. 若i==k，返回x；若ik，在大于x的元素中递归查找第i-k小的元素。...</p>
  </section>
  <footer class="entry-footer">
    <time>September 25, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/05-%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>HTTP状态码</h2>
  </header>
  <section class="entry-content">
   <p> HTTP状态码 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。
HTTP状态码的英文为HTTP Status Code。
下面是常见的HTTP状态码：
 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误  HTTP状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：
   分类 分类描述     1** 信息，服务器收到请求，需要请求者继续执行操作   2** 成功，操作被成功接收并处理   3** 重定向，需要进一步的操作以完成请求   4** 客户端错误，请求包含语法错误或无法完成请求   5** 服务器错误，服务器在处理请求的过程中发生了错误    HTTP状态码列表:    状态码 状态码英文名称 中文描述     100 Continue 继续。客户端应继续其请求   101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议        200 OK 请求成功。一般用于GET与POST请求   201 Created 已创建。成功请求并创建了新的资源   202 Accepted 已接受。已经接受请求，但未处理完成   203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   206 Partial Content 部分内容。服务器成功处理了部分GET请求        300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替   302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   303 See Other 查看其它地址。与301类似。使用GET和POST请求查看   304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源   305 Use Proxy 使用代理。所请求的资源必须通过代理访问   306 Unused 已经被废弃的HTTP状态码   307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向        400 Bad Request 客户端请求的语法错误，服务器无法理解   401 Unauthorized 请求要求用户的身份认证   402 Payment Required 保留，将来使用   403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求   404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面   405 Method Not Allowed 客户端请求中的方法被禁止   406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求   407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权   408 Request Time-out 服务器等待客户端发送的请求时间过长，超时   409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突   410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   412 Precondition Failed 客户端请求信息的先决条件错误   413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理   415 Unsupported Media Type 服务器无法处理请求附带的媒体格式   416 Requested range not satisfiable 客户端请求的范围无效   417 Expectation Failed 服务器无法满足Expect的请求头信息        500 Internal Server Error 服务器内部错误，无法完成请求   501 Not Implemented 服务器不支持请求的功能，无法完成请求   502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应   503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求   505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理    ...</p>
  </section>
  <footer class="entry-footer">
    <time>August 26, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/04-http%E7%8A%B6%E6%80%81%E7%A0%81/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>HTTP响应头信息</h2>
  </header>
  <section class="entry-content">
   <p>HTTP 响应头信息 HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。
在本章节中我们将具体来介绍HTTP响应头信息。
   应答头 说明     Allow 服务器支持哪些请求方法（如GET、POST等）。   Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。   Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。   Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。   Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。   Expires 应该在什么时候认为文档已经过期，从而不再缓存它？   Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。   Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。   Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&#34;)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=“Refresh” CONTENT=“5;URL=http://host/path&#34;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=“Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。   Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。   Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。   WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response....</p>
  </section>
  <footer class="entry-footer">
    <time>August 26, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/03-http%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BF%A1%E6%81%AF/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>HTTP content-type</h2>
  </header>
  <section class="entry-content">
   <p>HTTP content-type Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。
HTTP content-type 对照表    文件扩展名 Content-Type(Mime-Type) 文件扩展名 Content-Type(Mime-Type)     .*（ 二进制流，不知道下载文件类型） application/octet-stream .tif image/tiff   .001 application/x-001 .301 application/x-301   .323 text/h323 .906 application/x-906   .907 drawing/907 .a11 application/x-a11   .acp audio/x-mei-aac .ai application/postscript   .aif audio/aiff .aifc audio/aiff   .aiff audio/aiff .anv application/x-anv   .asa text/asa .asf video/x-ms-asf   .asp text/asp .asx video/x-ms-asf   ....</p>
  </section>
  <footer class="entry-footer">
    <time>August 26, 2017</time>
  </footer>
  <a class="entry-link" href="https://qiqi12138.github.io/post/01-http_content-type/"></a>
</article>




<footer class="page-footer">
  <nav class="pagination">
    
    <a class="prev" href="/post/page/3/">← Prev Page</a>
    
    
    <a class="next" href="/post/page/5/">Next Page →</a>
    
  </nav>
</footer>


</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://qiqi12138.github.io">qiqi12138</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://qiqi12138.github.io/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

