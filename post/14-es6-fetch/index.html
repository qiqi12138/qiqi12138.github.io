<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>ES6 - Fetch - qiqi12138</title>
    
    <meta name="description" content="Fetch Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。
这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。
请注意，fetch规范与jQuery.ajax()主
要有两种方式的不同，牢记：
 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。自从2017年8月25日后，默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值  进行 fetch 请求 一个基本的 fetch请求设置起来很简单。看看下面的代码：
fetch(&#39;http://example.com/movies.json&#39;) .then(function(response) { return response.json(); }) .then(function(myJson) { console.log(myJson); });  这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想fetch()到的资源路径，然后返回一个包含响应结果的promise(一个 Response 对象)。
当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 json()方法（在Bodymixin 中定义，被 Request 和 Response 对象实现）。">
    <meta name="author" content="">
    
    <link href="https://qiqi12138.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://qiqi12138.github.io/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://qiqi12138.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://qiqi12138.github.io/favicon.ico">
    
    <meta name="generator" content="Hugo 0.57.2" />
    
    <link rel="alternate" type="application/atom+xml" href="https://qiqi12138.github.io/index.xml" title="qiqi12138">
    
    
  </head>
  <body class="single">
    <header class="header">
      <nav class="nav">
        
        <p class="logo"><a href="https://qiqi12138.github.io">qiqi12138</a></p>
        
        
      </nav>
    </header>
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">ES6 - Fetch</h1>
    <div class="post-meta">March 3, 2018</div>
  </header>
  <div class="post-content">

<h1 id="fetch">Fetch</h1>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a>方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>

<p>这种功能以前是使用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorker_API"><code>Service Workers</code></a>。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。</p>

<p>请注意，<code>fetch</code>规范与<code>jQuery.ajax()</code>主</p>

<p>要有两种方式的不同，牢记：</p>

<ul>
<li>当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code>返回的 Promise <strong>不会被标记为 reject，</strong> 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 <code>ok</code> 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li>默认情况下，<code>fetch</code> <strong>不会从服务端发送或接收任何 cookies</strong>, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch#参数">credentials</a> 选项）。自从2017年8月25日后，默认的credentials政策变更为<code>same-origin</code>Firefox也在61.0b13中改变默认值</li>
</ul>

<hr />

<h2 id="进行-fetch-请求">进行 fetch 请求</h2>

<p>一个基本的 fetch请求设置起来很简单。看看下面的代码：</p>

<pre><code class="language-js">fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(myJson);
  });
</code></pre>

<p>这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想<code>fetch()</code>到的资源路径，然后返回一个包含响应结果的promise(一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象)。</p>

<p>当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body/json"><code>json()</code></a>方法（在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body"><code>Body</code></a>mixin 中定义，被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象实现）。</p>

<p><strong>注意</strong>：Body mixin 还有其他相似的方法，用于获取其他类型的内容。参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#Body">Body</a>。</p>

<p>最好使用符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives">内容安全策略 (CSP)</a>的链接而不是使用直接指向资源地址的方式来进行Fetch的请求。</p>

<h2 id="支持的请求参数">支持的请求参数</h2>

<p><code>fetch()</code> 接受第二个可选参数，一个可以控制不同配置的 <code>init</code> 对象：</p>

<p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a>，查看所有可选的配置和更多描述。</p>

<pre><code class="language-js">// Example POST method implementation:

postData('http://example.com/answer', {answer: 42})
  .then(data =&gt; console.log(data)) // JSON from `response.json()` call
  .catch(error =&gt; console.error(error))

function postData(url, data) {
  // Default options are marked with *
  return fetch(url, {
    body: JSON.stringify(data), // must match 'Content-Type' header
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, same-origin, *omit
    headers: {
      'user-agent': 'Mozilla/4.0 MDN Example',
      'content-type': 'application/json'
    },
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, cors, *same-origin
    redirect: 'follow', // manual, *follow, error
    referrer: 'no-referrer', // *client, no-referrer
  })
  .then(response =&gt; response.json()) // parses response to JSON
}
</code></pre>

<h2 id="发送带凭据的请求">发送带凭据的请求</h2>

<p>为了让浏览器发送包含凭据的请求（即使是跨域源），要将<code>credentials: 'include'</code>添加到传递给 <code>fetch()</code>方法的<code>init</code>对象。</p>

<pre><code>fetch('https://example.com', {
  credentials: 'include'  
})
</code></pre>

<p>如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加<code>credentials: 'same-origin'</code>。</p>

<pre><code class="language-js">// The calling script is on the origin 'https://example.com'

fetch('https://example.com', {
  credentials: 'same-origin'  
})
</code></pre>

<p>要改为确保浏览器不在请求中包含凭据，请使用<code>credentials: 'omit'</code>。</p>

<pre><code class="language-js">fetch('https://example.com', {
  credentials: 'omit'  
})
</code></pre>

<h2 id="上传-json-数据">上传 JSON 数据</h2>

<p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a>  POST JSON数据</p>

<pre><code class="language-js">var url = 'https://example.com/profile';
var data = {username: 'example'};

fetch(url, {
  method: 'POST', // or 'PUT'
  body: JSON.stringify(data), // data can be `string` or {object}!
  headers: new Headers({
    'Content-Type': 'application/json'
  })
}).then(res =&gt; res.json())
.catch(error =&gt; console.error('Error:', error))
.then(response =&gt; console.log('Success:', response));
</code></pre>

<h2 id="自定义请求对象">自定义请求对象</h2>

<p>除了传给 <code>fetch()</code> 一个资源的地址，你还可以通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request"><code>Request()</code></a> 构造函数来创建一个 request 对象，然后再作为参数传给 <code>fetch()</code>：</p>

<pre><code class="language-js">var myHeaders = new Headers();

var myInit = { method: 'GET',
               headers: myHeaders,
               mode: 'cors',
               cache: 'default' };

var myRequest = new Request('flowers.jpg', myInit);

fetch(myRequest).then(function(response) {
  return response.blob();
}).then(function(myBlob) {
  var objectURL = URL.createObjectURL(myBlob);
  myImage.src = objectURL;
});
</code></pre>

<p><code>Request()</code> 和 <code>fetch()</code> 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：</p>

<pre><code class="language-js">var anotherRequest = new Request(myRequest,myInit);
</code></pre>

<p>这个很有用，因为 request 和 response bodies 只能被使用一次（译者注：这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 <code>init</code> 参数。</p>

<p><strong>注意</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request/clone"><code>clone()</code></a> 方法也可以用于创建一个拷贝。它在语义上有一点不同于其他拷贝的方法。其他方法（比如拷贝一个 response）中，如果 request 的 body 已经被读取过，那么将执行失败，然而 <code>clone()</code> 则不会失败。</p>

<h2 id="headers">Headers</h2>

<p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers"><code>Headers</code></a> 的接口，你可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers"><code>Headers()</code></a> 构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多名值对：</p>

<pre><code class="language-js">var content = &quot;Hello World&quot;;
var myHeaders = new Headers();
myHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);
myHeaders.append(&quot;Content-Length&quot;, content.length.toString());
myHeaders.append(&quot;X-Custom-Header&quot;, &quot;ProcessThisImmediately&quot;);
</code></pre>

<p>也可以传一个多维数组或者对象字面量：</p>

<pre><code class="language-js">myHeaders = new Headers({
  &quot;Content-Type&quot;: &quot;text/plain&quot;,
  &quot;Content-Length&quot;: content.length.toString(),
  &quot;X-Custom-Header&quot;: &quot;ProcessThisImmediately&quot;,
});
</code></pre>

<p>它的内容可以被获取：</p>

<pre><code class="language-js">console.log(myHeaders.has(&quot;Content-Type&quot;)); // true
console.log(myHeaders.has(&quot;Set-Cookie&quot;)); // false
myHeaders.set(&quot;Content-Type&quot;, &quot;text/html&quot;);
myHeaders.append(&quot;X-Custom-Header&quot;, &quot;AnotherValue&quot;);
 
console.log(myHeaders.get(&quot;Content-Length&quot;)); // 11
console.log(myHeaders.getAll(&quot;X-Custom-Header&quot;)); // [&quot;ProcessThisImmediately&quot;, &quot;AnotherValue&quot;]
 
myHeaders.delete(&quot;X-Custom-Header&quot;);
console.log(myHeaders.getAll(&quot;X-Custom-Header&quot;)); // [ ]
</code></pre>

<p>虽然一些操作只能在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorker_API"><code>ServiceWorkers</code></a> 中使用，但是它提供了更方便的操作 Headers 的 API。</p>

<p>如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出 TypeError 异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：</p>

<pre><code class="language-js">var myResponse = Response.error();
try {
  myResponse.headers.set(&quot;Origin&quot;, &quot;http://mybank.com&quot;);
} catch(e) {
  console.log(&quot;Cannot pretend to be a bank!&quot;);
}
</code></pre>

<p>最佳实践是在使用之前检查 content type 是否正确，比如：</p>

<pre><code class="language-js">fetch(myRequest).then(function(response) {
  if(response.headers.get(&quot;content-type&quot;) === &quot;application/json&quot;) {
    return response.json().then(function(json) {
      // process your JSON further
    });
  } else {
    console.log(&quot;Oops, we haven't got JSON!&quot;);
  }
});
</code></pre>
</div>
  
  
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://qiqi12138.github.io">qiqi12138</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://qiqi12138.github.io/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

